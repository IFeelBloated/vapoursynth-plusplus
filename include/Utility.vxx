#pragma once
#include "Range.vxx"

template<typename UnknownType, typename ReferenceType>
concept SubtypeOf = std::same_as<std::decay_t<UnknownType>, ReferenceType> || std::derived_from<std::decay_t<UnknownType>, ReferenceType>;

template<typename UnknownType, typename ...ReferenceTypes>
concept AnyOf = (SubtypeOf<UnknownType, ReferenceTypes> || ...);

template<typename UnknownType, typename ...ReferenceTypes>
concept AnyBut = !AnyOf<UnknownType, ReferenceTypes...>;

template<typename UnknownType, typename ReferenceType>
concept ExplicitlyConvertibleTo = requires(UnknownType x) { static_cast<ReferenceType>(Forward(x)); };

template<typename UnknownType, typename ReferenceType>
concept ConstructibleFrom = ExplicitlyConvertibleTo<ReferenceType, std::decay_t<UnknownType>>;

template<typename UnknownType>
concept NativeArray = std::is_array_v<std::remove_cvref_t<UnknownType>>;

template<typename UnknownType>
concept Advanceable = requires(UnknownType x) { ++x; };

template<typename UnknownType>
concept Iterable = NativeArray<UnknownType> || requires(UnknownType x) {
	{ x.begin() }->Advanceable;
	{ *x.begin() }->AnyBut<void>;
	{ x.begin() != x.end() }->ExplicitlyConvertibleTo<bool>;
};

template<typename UnknownType>
concept IntegralOrEnumerable = std::integral<UnknownType> || std::is_enum_v<UnknownType>;

namespace Utility {
	auto Max(auto x, auto y) {
		return x > y ? x : y;
	}
	auto Min(auto x, auto y) {
		return x < y ? x : y;
	}
	auto Log2(auto x) {
		auto Exponent = 0;
		while (x != 1) {
			x >>= 1;
			++Exponent;
		}
		return Exponent;
	}
	auto TypeEraseIterableToTriplet(auto&& Entity) {
		if constexpr (Iterable<decltype(Entity)>) {
			auto Buffer = [&] {
				if constexpr (NativeArray<decltype(Entity)>)
					return std::vector<std::decay_t<decltype(Entity[0])>>{};
				else
					return std::vector<std::decay_t<decltype(*Entity.begin())>>{};
			}();
			for (auto&& x : Entity)
				if constexpr (std::is_rvalue_reference_v<decltype(Entity)>)
					Buffer.push_back(std::move(x));
				else
					Buffer.push_back(x);
			if (Buffer.size() >= 3)
				return std::array{ std::move(Buffer[0]), std::move(Buffer[1]), std::move(Buffer[2]) };
			else if (Buffer.size() == 2)
				return std::array{ std::move(Buffer[0]), Buffer[1], std::move(Buffer[1]) };
			else if (Buffer.size() == 1)
				return std::array{ Buffer[0], Buffer[0], std::move(Buffer[0]) };
			else
				throw std::runtime_error{ "TypeEraseIterableToTriplet: failed to convert iterable object to std::array<auto, 3>." };
		}
		else
			return std::array{ Entity, Entity, Forward(Entity) };
	}
	auto ExposeCharPointerIfASCIZCompatibleOrDeepCopyIfNot(auto&& ReferenceString) {
		if constexpr (SubtypeOf<decltype(ReferenceString), std::string>)
			return ReferenceString.data();
		else if constexpr (requires { { Forward(ReferenceString) }->std::convertible_to<const char*>; })
			return static_cast<const char*>(Forward(ReferenceString));
		else if constexpr (Iterable<decltype(ReferenceString)> && requires { { *ReferenceString.begin() }->SubtypeOf<char>; })
			return std::string{ ReferenceString.begin(), ReferenceString.end() };
	}
	auto ExtractCharPointerFromASCIZFormattedString(auto&& FormattedString) {
		if constexpr (requires { FormattedString.data(); })
			return FormattedString.data();
		else
			return FormattedString;
	}
}

namespace Utility::PointerQualifiers {
	auto DropAll(auto Pointer) {
		using ReferencedType = std::remove_cvref_t<decltype(*Pointer)>;
		return const_cast<ReferencedType*>(Pointer);
	}
	auto AddConst(auto Pointer) {
		using ReferencedType = std::remove_cvref_t<decltype(*Pointer)>;
		return const_cast<const ReferencedType*>(Pointer);
	}
}

namespace Utility::Reflection::Private {
	template<typename>
	consteval auto EmbedTypeNameIntoSignature() {
		return std::string_view{ std::source_location::current().function_name() };
	}
	template<typename, typename>
	struct ContainerReplaceTypeArgument {};
	template<template<typename> typename ContainerTypeConstructor, typename TypeBeingReplaced, typename TargetElementType>
	struct ContainerReplaceTypeArgument<ContainerTypeConstructor<TypeBeingReplaced>, TargetElementType> {
		using ReassembledType = ContainerTypeConstructor<TargetElementType>;
	};
	template<template<typename, auto> typename ContainerTypeConstructor, typename TypeBeingReplaced, auto Length, typename TargetElementType>
	struct ContainerReplaceTypeArgument<ContainerTypeConstructor<TypeBeingReplaced, Length>, TargetElementType> {
		using ReassembledType = ContainerTypeConstructor<TargetElementType, Length>;
	};
	template<template<typename, typename> typename ContainerTypeConstructor, template<typename> typename AllocatorTypeConstructor, typename TypeBeingReplaced, typename TargetElementType>
	struct ContainerReplaceTypeArgument<ContainerTypeConstructor<TypeBeingReplaced, AllocatorTypeConstructor<TypeBeingReplaced>>, TargetElementType> {
		using ReassembledType = ContainerTypeConstructor<TargetElementType, AllocatorTypeConstructor<TargetElementType>>;
	};
}

namespace Utility::Reflection {
	template<typename UnknownType>
	consteval auto ReifyTypeNameIntoString() {
		constexpr auto SignatureTemplate = Private::EmbedTypeNameIntoSignature<double>();
		constexpr auto EmbeddingSignature = Private::EmbedTypeNameIntoSignature<UnknownType>();
		constexpr auto CaptionLength = SignatureTemplate.find("double");
		constexpr auto EnclosureLength = SignatureTemplate.size() - CaptionLength - "double"sv.size();
		return EmbeddingSignature.substr(CaptionLength, EmbeddingSignature.size() - CaptionLength - EnclosureLength);
	}
	template<typename ReferenceContainerType, typename TargetElementType>
	using ContainerReplaceElementType = Private::ContainerReplaceTypeArgument<std::decay_t<ReferenceContainerType>, TargetElementType>::ReassembledType;
}

namespace Utility::SignatureParser::Tokenizer {
	auto Replace(auto TokenizedParameterList, auto ReferenceToken, auto TargetToken, auto ...TokenPairs) {
		if constexpr (auto RetokenizedParameterList = std::regex_replace(TokenizedParameterList, std::regex{ ReferenceToken }, TargetToken); sizeof...(TokenPairs) == 0)
			return RetokenizedParameterList;
		else
			return Replace(std::move(RetokenizedParameterList), TokenPairs...);
	}
}

namespace Utility::SignatureParser {
	auto DeduceFunctionName(auto&& PartialSignature, auto&& ...Fallback) {
		auto ReferenceSignature = static_cast<std::string>(Forward(PartialSignature));
		if (auto SectorMarker = ReferenceSignature.find("("); SectorMarker != std::string::npos)
			return std::regex_replace(ReferenceSignature.substr(0, SectorMarker), std::regex{ R"(\s)" }, "");
		else
			if constexpr (sizeof...(Fallback) > 0)
				return std::string{ Forward(Fallback)... };
			else
				return ""s;
	}
	auto ExtractParameterList(auto&& PartialSignature) {
		auto ReferenceSignature = static_cast<std::string>(Forward(PartialSignature));
		auto ParameterListSector = [&] {
			if (auto SectorMarker = ReferenceSignature.find("("); SectorMarker != std::string::npos)
				return SectorMarker + 1;
			else
				return static_cast<decltype(SectorMarker)>(0);
		}();
		auto ReturnKeySector = [&] {
			if (auto SectorMarker = ReferenceSignature.find(")"); SectorMarker != std::string::npos)
				return SectorMarker;
			else
				return ReferenceSignature.find("->");
		}();
		auto FormatParameterList = [](auto ExtractedParameterList) {
			auto TokenizedParameterList = Tokenizer::Replace(std::move(ExtractedParameterList), R"(\s)", "", R"(\?)", ":opt", ",", ";", ":vnode", ":clip", ":vframe", ":frame", ":string", ":data");
			auto FlattenParameterGroups = [&] {
				auto FlattenedParameterList = std::ostringstream{};
				auto PatternForParameterGroups = std::regex{ R"(\[([^\]]+)\]:([^;]+))" };
				auto ParameterGroup = std::sregex_iterator{ TokenizedParameterList.begin(), TokenizedParameterList.end(), PatternForParameterGroups };
				auto NoMatch = std::sregex_iterator{};
				auto ParameterListNeedsFlattening = ParameterGroup != NoMatch;
				while (ParameterGroup != NoMatch) {
					FlattenedParameterList << ParameterGroup->prefix() << std::regex_replace(ParameterGroup->str(1), std::regex{ ";" }, ":" + ParameterGroup->str(2) + ";") << ":" + ParameterGroup->str(2);
					if (std::next(ParameterGroup) == NoMatch)
						FlattenedParameterList << ParameterGroup->suffix();
					++ParameterGroup;
				}
				return std::tuple{ ParameterListNeedsFlattening, std::move(FlattenedParameterList).str() };
			};
			if (auto [ParameterListNeedsFlattening, FlattenedParameterList] = FlattenParameterGroups(); ParameterListNeedsFlattening)
				TokenizedParameterList = std::move(FlattenedParameterList);
			if (TokenizedParameterList.size() > 0 && TokenizedParameterList[TokenizedParameterList.size() - 1] != ';')
				TokenizedParameterList.push_back(';');
			return TokenizedParameterList;
		};
		return FormatParameterList(ReferenceSignature.substr(ParameterListSector, ReturnKeySector == std::string::npos ? ReturnKeySector : ReturnKeySector - ParameterListSector));
	}
	auto DeduceReturnKey(auto&& PartialSignature, auto&& Fallback) {
		auto ReferenceSignature = static_cast<std::string>(Forward(PartialSignature));
		if (auto SectorMarker = ReferenceSignature.find("->"); SectorMarker != std::string::npos)
			return std::regex_replace(ReferenceSignature.substr(SectorMarker + 2), std::regex{ R"(\s)" }, "");
		else
			return static_cast<std::string>(Forward(Fallback));
	}
}

namespace Utility::Map {
	auto Create();
	auto ListKeys(auto);
	auto Fill(auto, auto&&, auto&&, auto&&...);
	auto CheckForError(auto);
	auto DeduceReturnKey(auto, auto);
	template<auto = true, auto = true>
	auto AccessItem(auto, auto&&);
}

namespace Utility::PaddingFunctions {
	auto ReflectCoordinate(auto x, auto Bound) {
		while (x < 0 || x >= Bound) {
			x = std::abs(x);
			x -= Bound - 1;
			x = -std::abs(x);
			x += Bound - 1;
		}
		return x;
	}
}